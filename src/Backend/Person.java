package Backend;

import java.text.SimpleDateFormat;
import java.util.*;

/**
 * Represents one person from the database.
 * Each person object is unique, as based on the ID field.
 */
public class Person
{
    /**
     * The ID associated with this Person.
     */
    private int ID;

    /**
     * The first name of this Person.
     */
    private String firstName;

    /**
     * The last name of this Person.
     */
    private String lastName;

    /**
     * Boolean representing whether or not this Person is infected.
     */
    private boolean infected;

    /**
     * The Range of time that this Person is contagious for.
     */
    private Range infectionRange;

    /**
     * The number of Interactions this Person is involved in.
     */
    private int numTotalInteractions = 0;

    /**
     * Constant specifying the conversion of a day to milliseconds.
     */
    private final int DAYINMILLIS = 86400000;

    /**
     * Contains all the relationships a person has. This is a more complete picture of a persons interactions with one
     *  other individual.
     */
    private TreeMap<Integer,Relationship> relationships = new TreeMap<Integer, Relationship>();

    /**
     * Contains all the interactions the person is involved in. Generated by the InteractionsList.
     */
    private TreeSet<Interaction> personalInteractionSet = new TreeSet<Interaction>();

    /**
     * Constructor for Objects of class Person.
     * @param ID the ID associated with this Person
     * @param first the first name of this Person
     * @param last the last name of this Person
     * @param infected boolean representing whether or not this Person is infected
     * @param timeReported the Range of time that this Person is contagious for
     */
    public Person(int ID, String first, String last, boolean infected, long timeReported){
        this.ID = ID;
        firstName = first;
        lastName = last;
        this.infected = infected;
        infectionRange = new Range(timeReported - DAYINMILLIS, timeReported + 7*DAYINMILLIS );
    }

    /**
     * Accessor method for the ID associated with this Person.
     * @return the ID associated with this Person
     */
    public int getID(){return ID;}

    /**
     * Setter method for the set of Interactions this Person is involved in.
     * @param set the set of Interactions this Person is involved in
     */
    public void setInteractionSet(TreeSet<Interaction> set){
        personalInteractionSet = set;
        numTotalInteractions = set.size();
    }

    /**
     * Accessor method for the number of Interactions this Person is involved in.
     * @return the number of Interactions this Person is involved in
     */
    public int getInteractionSetSize() {return numTotalInteractions;}

    /**
     * Accessor method for the Range of time this Person is contagious for.
     * @return the Range of time this Person is contagious for
     */
    public Range getInfectionRange(){return infectionRange;}

    /**
     * Accessor method for the set of Interactions this Person is involved in.
     * @return the set of Interactions this Person is involved in
     */
    public TreeSet<Interaction> getInteractionSet(){return personalInteractionSet;}

    /**
     * Accessor method for the first name of this Person.
     * @return the first name of this Person
     */
    public String getFirstName(){return firstName;}

    /**
     * Accessor method for the last name of this Person.
     * @return the last name of this Person
     */
    public String getLastName(){return lastName;}

    /**
     * Goal of this method is to remove Interactions that would not infect a person
     * as well as combine interactions that flow into each other (e.g. last longer than the location update interval)
     * into one interaction.
     *
     * As it is written, it will make personalInteractionSet inaccurate, as such, after it is run we should focus on relationships.
     */
    public void consolidateInteractions(){
        Iterator itr = personalInteractionSet.iterator();
        if(itr.hasNext()){
            Interaction current = (Interaction) itr.next();
            while(itr.hasNext()) {
                Interaction next = (Interaction) itr.next();
            //Check if the interaction occurred before or after one of the two people was infected, if it was ignore it.
                if (current.getTimePeriod().getUpperBound() < current.getPersonB().getInfectionRange().getLowerBound()
                        || current.getTimePeriod().getUpperBound() < infectionRange.getLowerBound()
                        || current.getTimePeriod().getLowerBound() > current.getPersonB().getInfectionRange().getUpperBound()
                        || current.getTimePeriod().getLowerBound() > infectionRange.getUpperBound())
                    current = next;
                else {
                    if (current.shallowEquals(next)) {
                        current = current.combineInteractions(next);
                    } else {
                        current.setChecked();
                        if (relationships.containsKey(current.getPersonBID())) {
                            Relationship update = relationships.get(current.getPersonBID());
                            update.addInteraction(current);
                            relationships.put(current.getPersonBID(), update);
                        } else if(current.getPersonB().getInfectionRange().getLowerBound() < infectionRange.getLowerBound()) {
                            relationships.put(current.getPersonBID(), new Relationship(current.getPersonB(), getInteractionSetSize()));
                        }
                        current = next;
                    }
                }
            }
        }
    }

    /**
     * Compute the infection likelihood of each relationship
     *
     * Not the nicest statement in the for loop but whatever it works.
     */
    public void buildRelationshipInfectionChance(){
        countTotalInteractions();
        for(Map.Entry<Integer, Relationship> entry: relationships.entrySet()){
           entry.getValue().computeInfectionLikeliHood(numTotalInteractions);
        }
    }

    public void countTotalInteractions(){
        numTotalInteractions = 0;
        for(Map.Entry<Integer, Relationship> entry: relationships.entrySet()){
            numTotalInteractions += entry.getValue().getTimesInteracted();
        }
    }


    /**
     * Debugging tool to print out the Relationships this Person is involved in.
     */
    public void printRelationships(){
        System.out.println("Infection chances for: "+ firstName + " " + lastName);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy.MM.dd 'at' HH:mm:ss");
        System.out.println("Infection reported at: " + sdf.format(new Date(getInfectionRange().getLowerBound() + 86400000)));
        if(relationships.size() == 0){
            System.out.println("No relationships found that could have caused infection.");
        }
        for(Map.Entry<Integer,Relationship> entry : relationships.entrySet()) {
            int key = entry.getKey();
            Relationship next = entry.getValue();
            Person other = next.getOtherPerson();
            double infectionlikelihood = next.getInfectionLikelihood();
            System.out.println("Infection Likelihood from " + other.getFirstName() +
                    " " + other.getLastName() + " is: " + next.getInfectionLikelihood()+
                            "\n\t Number of times interacted: " + next.getTimesInteracted()+
                            "\n\t Average scaled interaction length: " + next.getAverageInteractionLengthDistance() + "\n"
            );
        }
        System.out.println("\n");
    }
}
